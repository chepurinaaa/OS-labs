Лабраторная работа № 1

Установка Linux/ Mac OS X

Редактор + использование grep; 

Grep это утилита командной строки Linux, который даёт пользователям возможность вести поиск строки. С его помощью можно даже искать конкретные слова в файле.
![alt text](file:///home/arina/Pictures/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%20%D0%BE%D1%82%202020-05-26%2021-51-39.png)

Ключ -с - поиск с подсчетом количества

Ключ -w - поиск по слову целиком

. - вывод содержимого всего файла

![alt text](file:///home/arina/Pictures/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%20%D0%BE%D1%82%202020-06-21%2010-21-58.png)

Компиляция, отладка и выполнение, полезные флаги.

-c - компиляция программы и генерация машинного кода, без создания исполняемого файла

-S - компиляция и генерация кода ассемблера

![alt text](file:///home/arina/Pictures/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%20%D0%BE%D1%82%202020-06-21%2010-36-27.png)
![alt text](file:///home/arina/Pictures/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%20%D0%BE%D1%82%202020-06-21%2010-36-40.png)

-o - задать имя исполняемого файла

![alt text](file:///home/arina/Pictures/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%20%D0%BE%D1%82%202020-06-21%2010-39-30.png)

-E - запуск только препроцессора - он содержит код из всех подключенных библиотек

![alt text](file:///home/arina/Pictures/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%20%D0%BE%D1%82%202020-06-21%2010-41-09.png)

-Wall - вывод всех ошибок и предупреждений

![alt text](file:///home/arina/Pictures/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%20%D0%BE%D1%82%202020-06-21%2010-43-32.png)

-g - отладочная информация для работы с отладчиком - файл с отладочными данными занимает больше места на диске

![alt text](file:///home/arina/Pictures/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%20%D0%BE%D1%82%202020-06-21%2010-47-16.png)

-O - контролирование уровня оптимизации

![alt text](file:///home/arina/Pictures/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%20%D0%BE%D1%82%202020-06-21%2010-49-24.png)

nm - выводится информацию о бинарных файлах

![alt text](file:///home/arina/Pictures/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%20%D0%BE%D1%82%202020-06-21%2010-52-42.png)

подключение библиотек

статические .a: чтобы создать статическю библиотеку из файлов main1.c & main2.c нужно сначала скомпилировать эти файлы, результат даст два объектных файла main1.o & main2.o. Чтобы создать библиотеку из объектных файлов надо вызвать программу ar с параметрами: ar rc lib[имя_библиотеки].a [файлы.o]. В результате получим файл lib[имя_библиотеки].a в котором будут лежать копии объектых фалов. Чтобы из этого файла сделать полноценную библиотеку надо добавить к этому архиву список вложенных в библиотеку функций и переменных, чтобы линковка происходила быстрее. Делается это командой: ranlib lib[имя_библиотеки].a. Для компиляции нашего основного файла main.c надо сообщить компилятору, что надо использовать библиотеки. Чтобы компилятор знал где искать библиотеки ему надо сообщить каталог, в котором они содержатся и список этих билиотек. Каталог с библиотеками указывается ключом -L, в нашем случае библиотека находится в текущем каталоге, значит путь до нее будет в виде точки (-L.). Используемые библиотеки перечисляются через ключ -l, после которого указывается название библиотеки без префикса lib и окончания .a. В нашем случае этот ключ будет выглядеть, как -lfs.

![alt text](file:///home/arina/Pictures/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%20%D0%BE%D1%82%202020-06-21%2011-17-44.png)

динамические .so: Для начала требуется, чтобы переходы в функциях библиотеки (операции goto на ассемблере) использовали не абсолютную адресацию, а относительную. То есть генерируемый компилятором код должен быть независимым от адресов, такая технология получила название PIC - Position Independent Code. В компиляторе gcc данная возможность включается ключом -fPIC. Для того, чтобы создать динамическую библиотеку надо использовать ключ -shared. В результате получим динамическую библиотеку libdyn.so. Использование специальной переменной среды LD_LIBRARY_PATH, в которой перечисляются все каталоги содержащие пользовательские динамические библиотеки.

![alt text](file:///home/arina/Pictures/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%20%D0%BE%D1%82%202020-06-21%2011-24-17.png)

связывание, например, math.h - с помощью ключа -lm

![alt text](file:///home/arina/Pictures/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%20%D0%BE%D1%82%202020-06-21%2011-47-07.png)

Пример отладки простой ошибочной программы

![alt text](file:///home/arina/Pictures/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%20%D0%BE%D1%82%202020-06-21%2011-50-32.png)

Применение Makefile для автоматизации (синтаксис, использование правил и переменных) make — утилита предназначенная для автоматизации преобразования файлов из одной формы в другую. Правила преобразования задаются в скрипте с именем Makefile, который должен находиться в корне рабочей директории проекта. Сам скрипт состоит из набора правил, описывающимися целями - что правило делает, реквизитами - что необходимо и командами.

`<цели>: <реквизиты> <команда> ... <команда>`

Использовать несколько целей в одном мейкфайле полезно для больших проектов. Это связано с тем, что при изменении одного файла не понадобится пересобирать весь проект, а можно будет обойтись пересборкой только измененной части.
Правило задания переменных <VAR_NAME> = Для использования значения переменной ее следует разименовать при помощи конструкции $(<VAR_NAME>).

![alt text](file:///home/arina/Pictures/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%20%D0%BE%D1%82%202020-06-21%2012-04-16.png)





