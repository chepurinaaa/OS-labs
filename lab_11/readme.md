Лабораторная работа №11

`1.` vector-deadlock.c,  main-common.c и др.:
-Выполнить  ./vector-deadlock -n 2 -l 1 -v
которая инициирует 2 потока  (-n 2) и каждый из них осуществляет одно  сложение (-1 1) с опцией (-v).
Объяснить результат. Меняется ли он от вызова к вызову? 
- Добавить флаг  -d и изменить количество циклов  -l .
Всегда ли возникает состояние взаимной блокировки потоков (deadlock)?

При выставлении флага -d блокировка случается, но редко и при очень больших значениях -l.

- Теперь меняем число потоков -n. Есть ли такое число потоков, при котором блокировка не возникает?

При смене числа потоков так же можно добиться deadlock. Блокировки не будет возникать, если один поток.


    -d  
       Этот флаг включает возможность блокировки потоков.
       Когда вы передаете -d программе, каждый другой поток вызывает vector_add () 
       с векторами в другом порядке, например, с двумя потоками, и -d включен, 
       Поток 0 вызывает vector_add (v1, v2), а поток 1 вызывает vector_add (v2, v1)
    -p
       Этот флаг дает каждому потоку различный набор векторов для вызова add () 
       когда нет конкуренции за один и тот же набор векторов. 
    -n num_threads
       Создает некоторое количество потоков; вам нужно больше, чем один, чтобы зайти в deadlock.
    -l loops
       Сколько раз каждый поток должен вызывать vector_add ()?
    -v 
       Подробный флаг: распечатывает немного больше о том, что происходит.
    -t
       Включает тайминг и показывает, как долго все прошло.
      
Эта программа захватывает lock в определенном порядке. Она создает условия для deadlock, так как один поток может вызвать vector_add (v1, v2), в то время как другой вызовет одновременно vector_add (v2, v1). 

Вывод меняется, т. к. потоки не всегла перехватывают выполнение в одно и то же время. Но т. к. в программе порядок установлен верно, то deadlock не происходит.


`2.` vector-global-order.c:
- За счет чего программа избегает блокировок? 

Эта программа упорядочивает блокировку, независимо от того что ей передается. Эта версия vector_add () захватывает lock в общем порядке на основе адрес вектора.

- Для чего предусмотрен специальный случай в vector add(), когда исходный и результирующий вектор совпадают?

Существует особый случай, когда src и dst совпадают, потому что в этом случае необходимо получить только одну блокировку. Без этого особого случая будет гарантирован deadlock.

- Флаги: -t -n 2 -l 100000 -d. Как меняется время в зависимости от числа циклов и числа потоков?

![alt text](https://github.com/chepurinaaa/OS-labs/blob/master/pic/11_2.png)

Зависимость от l понятна - чем больше l, тем больше времени на выполнение потребуется.

- Что происходит, когда включается ключ -p (при сложении различных векторов и одного и того же)?

Скорость выполнения увеличивается, так как теперь потокам не нужно ждать тех же двух блокировок. Номеров векторов стало больше, поэтому локи ставятся реже.

![alt text](https://github.com/chepurinaaa/OS-labs/blob/master/pic/11_3.png)

`3.` vector-try-wait.c: 

Эта версия vector_add () использует pthread_mutex_trylock (), чтобы попытаться захватить lock; когда попытка не удалась, код освобождает любые блокировки, которые он может удерживать возвращается наверх и пробует все заново.

- Нужен ли первый вызов  pthread mutex trylock()?

Первый вызов нужен, чтобы заблокировать вектор в первый раз, так как trylock блокирует в случае удачи.

- Как меняется число повторных попыток, когда растет число потоков?3.

Чем больше потоков, тем больше попыток. т.к. большее количество потоков пытаются заблокировать вновь и вновь.

`4.` vector-avoid-hold-and-wait.c: 

- Сравнить с другими подходами.

Основная проблема этого подхода заключается в том, что глобальная блокировка будет ставить lock, даже если векторы каждого потока различны. Этот способ работает лучше предыдущего.

- Как меняется производительность в зависимости от наличия флага -p?

![alt text](https://github.com/chepurinaaa/OS-labs/blob/master/pic/11_4.png)

C -p флагом все работает значительно быстрее. Время выполнения (без флага -p) очень близко к таковому для vector-global-order.


`5.` vector-nolock.c:

- Сравнить семантику и производительность с другими вариантами при работе с двумя одинаковыми векторами и в случае, когда каждый поток работает на своем векторе  -p.

![alt text](https://github.com/chepurinaaa/OS-labs/blob/master/pic/11_5.png)

Эта версия vector_add () даже не использует блокировки; Она использует atomic fetch-and-add для реализации подпрограммы vector_add (). Ее семантика немного отличается от предыдущих. Этот вариант атомарнен в отношении добавления пары записей.







       