Лабораторная работа № 10

`1.` Предположим, что процесс открывает файл на чтение по единственной жесткой ссылке (hard link) на существующий файл. В процессе этого чтения другой процесс удаляет эту ссылку. Что случится с операцией чтения первым процессом? Она завершится успешно?
     Написать программу и протестировать (также объяснить результат на основе документации). 
     
 unlink удаляет имя из файловой системы. Если это имя было последней ссылкой на файл и больше нет процессов, которые держат этот файл открытым, данный файл удаляется и место, которое он занимает освобождается для дальнейшего использования.
 
 Если имя было посленей ссылкой на файл, но какие-либо процессы всё ещё держат этот файл открым, файл будет оставлен пока последний файловый дескриптор, указывающий на него, не будет закрыт. 
  
`2.` Каково время выполнения программы, содержащей  2,000,000 инструкций на процессоре  8 MHz, когда каждая инструкция занимает 4 цикла.   
  
Так как каждая инструкция занимает 4 цикла, то все количество инструкций будет = 8,000,000

8MHz = 8,000,000Hz, чтобы узнать количество времени, затраченного на выполение 8,000,000 инструкций на процессоре 8,000,000Hz, поделим количество на частоту, следовательно, потребуется 1 сек.

`3.` Рассмотреть систему, в которой виртуальный адрес 20 бит, а страница  1 KB. Сколько элементов в таблице страниц?

Размерность адреса 20 бит, следовательно, можно закодировать 2^20 адресов - это будет размерность адресного пространства. Чтобы посчитать сколько элементов в таблице страниц нужно разделить все адресное пространство 2^20 на размер страницы 1КБ = 2^10 байт, получим 2^10.

`4.` Рассмотреть алгоритмы диспетчеризации процессов (scheduling algorithms) по следующим критериям (метрикам)

(a) время ожидания (waiting time), 

(b) повышение приоритета "забытой" задачи (starvation), 

(c) время завершения (turnaround time), 

(d) вариативность времени завершения  (variance in turnaround time).

Какой из них приведет к высокой вариативности времени завершения?  

Одним из наиболее ограниченных ресурсов вычислительной системы является процессорное время. Для его распределения между многочисленными процессами в системе приходится применять процедуру планирования процессов.

Вытесняющее планирование.

В этом режиме планирования процесс может быть приостановлен в любой момент исполнения. Операционная система устанавливает специальный таймер для генерации сигнала прерывания по истечении некоторого интервала времени – кванта. После прерывания процессор передается в распоряжение следующего процесса. Временные прерывания помогают гарантировать приемлемое время отклика процессов для пользователей, работающих в диалоговом режиме, и предотвращают "зависание" компьютерной системы из-за зацикливания какой-либо программы.

Невытесняющее планирование.

При таком режиме планирования процесс занимает столько процессорного времени, сколько ему необходимо. При этом переключение процессов возникает только при желании самого исполняющегося процесса передать управление. Этот метод планирования относительно просто реализуем и достаточно эффективен, так как позволяет выделить большую часть процессорного времени для работы самих процессов и до минимума сократить затраты на переключение контекста. Однако при невытесняющем планировании возникает проблема возможности полного захвата процессора одним процессом, который вследствие каких-либо причин (например, из-за ошибки в программе) зацикливается и не может передать управление другому процессу. В такой ситуации спасает только перезагрузка всей вычислительной системы.

Простейшим алгоритмом планирования является алгоритм, который принято обозначать аббревиатурой FIFO по первым буквам его английского названия – First-In, First-Out (первым пришел, первым обслужен). Такой алгоритм выбора процесса осуществляет невытесняющее планирование.


    (a) время ожидания (waiting time) - зависят от порядка расположения процессов
    (b) повышение приоритета "забытой" задачи (starvation) - процесс занимает столько процессорного времени, сколько ему необходимо
    (c) время завершения (turnaround time) - зависят от порядка расположения процессов
    (d) вариативность времени завершения (variance in turnaround time) - процесс занимает столько процессорного времени, сколько ему необходимо

Модификацией алгоритма FIFO является алгоритм, получивший название Round Robin. Это тот же самый алгоритм, только реализованный в режиме вытесняющего планирования. Каждый процесс находится около процессора небольшой фиксированный квант времени.

При очень больших величинах кванта времени, алгоритм RR вырождается в алгоритм FCFS. При очень малых величинах создается иллюзия того, что каждый из n процессов работает на собственном виртуальном процессоре с производительностью ~ 1/n от производительности реального процессора. Правда, это справедливо лишь при теоретическом анализе при условии пренебрежения временами переключения контекста процессов.

В реальных условиях при слишком малой величине кванта времени и, соответственно, слишком частом переключении контекста накладные расходы на переключение резко снижают производительность системы.


    (a) время ожидания (waiting time) - каждый процесс находится около процессора небольшой фиксированный квант времени
    (b) повышение приоритета "забытой" задачи (starvation) - тут он аналогичен FCFS
    (c) время завершения (turnaround time) - при слишком малой величине кванта времени и, соответственно, слишком частом переключении контекста накладные расходы на переключение резко снижают производительность системы, а при большом он вырождается в FCFS
    (d) вариативность времени завершения (variance in turnaround time) - зависит от кванта.


SJF-алгоритм краткосрочного планирования может быть как вытесняющим, так и невытесняющим.

При невытесняющем SJF - планировании процессор предоставляется избранному процессу на все необходимое ему время, независимо от событий, происходящих в вычислительной системе.

При вытесняющем SJF - планировании учитывается появление новых процессов в очереди готовых к исполнению (из числа вновь родившихся или разблокированных) во время работы выбранного процесса. Если время выполнения нового процесса меньше, чем остаток у исполняющегося, то исполняющийся процесс вытесняется новым.


    (a) время ожидания (waiting time) - если алгоритм вытесняющий: то процесс с наименьшим временем выполнения вытесняет другой. Иначе, процесс получает все время, что ему необходимо.
    (b) повышение приоритета "забытой" задачи (starvation) - если процесс занимает много времени, то он может долго ожидать выполнения
    (c) время завершения (turnaround time) - бытрые процессы выполняются быстро, когда как длительные ожидают своего выполненния
    (d) вариативность времени завершения (variance in turnaround time) - присутсвует.


Приведет к высокой вариативности времени завершения скорее всего FCFS, так как он просто выполняет процессы в порядке очереди. Следующим за ним будет FJS, так время завершения будет просто увеличиваться, казалось бы. И последний RR, зависящий от кванта времени на процесс.


