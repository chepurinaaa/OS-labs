Лабраторная работа № 1

Установка Linux/ Mac OS X

Редактор + использование grep; 

Grep это утилита командной строки Linux, который даёт пользователям возможность вести поиск строки. С его помощью можно даже искать конкретные слова в файле.
![alt text](https://github.com/chepurinaaa/OS-labs/blob/master/pic/1_1.png)

Ключ -с - поиск с подсчетом количества

Ключ -w - поиск по слову целиком

. - вывод содержимого всего файла

![alt text](https://github.com/chepurinaaa/OS-labs/blob/master/pic/1_2.png)

Компиляция, отладка и выполнение, полезные флаги.

-c - компиляция программы и генерация машинного кода, без создания исполняемого файла

-S - компиляция и генерация кода ассемблера

![alt text](https://github.com/chepurinaaa/OS-labs/blob/master/pic/1_3.png)
![alt text](https://github.com/chepurinaaa/OS-labs/blob/master/pic/1_4.png)

-o - задать имя исполняемого файла

![alt text](https://github.com/chepurinaaa/OS-labs/blob/master/pic/1_5.png)

-E - запуск только препроцессора - он содержит код из всех подключенных библиотек

![alt text](https://github.com/chepurinaaa/OS-labs/blob/master/pic/1_6.png)

-Wall - вывод всех ошибок и предупреждений

![alt text](https://github.com/chepurinaaa/OS-labs/blob/master/pic/1_7.png)

-g - отладочная информация для работы с отладчиком - файл с отладочными данными занимает больше места на диске

![alt text](https://github.com/chepurinaaa/OS-labs/blob/master/pic/1_8.png)

-O - контролирование уровня оптимизации

![alt text](https://github.com/chepurinaaa/OS-labs/blob/master/pic/1_9.png)

nm - выводится информацию о бинарных файлах

![alt text](https://github.com/chepurinaaa/OS-labs/blob/master/pic/1_10.png)
подключение библиотек

статические .a: чтобы создать статическю библиотеку из файлов main1.c & main2.c нужно сначала скомпилировать эти файлы, результат даст два объектных файла main1.o & main2.o. Чтобы создать библиотеку из объектных файлов надо вызвать программу ar с параметрами: ar rc lib[имя_библиотеки].a [файлы.o]. В результате получим файл lib[имя_библиотеки].a в котором будут лежать копии объектых фалов. Чтобы из этого файла сделать полноценную библиотеку надо добавить к этому архиву список вложенных в библиотеку функций и переменных, чтобы линковка происходила быстрее. Делается это командой: ranlib lib[имя_библиотеки].a. Для компиляции нашего основного файла main.c надо сообщить компилятору, что надо использовать библиотеки. Чтобы компилятор знал где искать библиотеки ему надо сообщить каталог, в котором они содержатся и список этих билиотек. Каталог с библиотеками указывается ключом -L, в нашем случае библиотека находится в текущем каталоге, значит путь до нее будет в виде точки (-L.). Используемые библиотеки перечисляются через ключ -l, после которого указывается название библиотеки без префикса lib и окончания .a. В нашем случае этот ключ будет выглядеть, как -lfs.

![alt text](https://github.com/chepurinaaa/OS-labs/blob/master/pic/1_11.png)

динамические .so: Для начала требуется, чтобы переходы в функциях библиотеки (операции goto на ассемблере) использовали не абсолютную адресацию, а относительную. То есть генерируемый компилятором код должен быть независимым от адресов, такая технология получила название PIC - Position Independent Code. В компиляторе gcc данная возможность включается ключом -fPIC. Для того, чтобы создать динамическую библиотеку надо использовать ключ -shared. В результате получим динамическую библиотеку libdyn.so. Использование специальной переменной среды LD_LIBRARY_PATH, в которой перечисляются все каталоги содержащие пользовательские динамические библиотеки.

![alt text](https://github.com/chepurinaaa/OS-labs/blob/master/pic/1_12.png)

связывание, например, math.h - с помощью ключа -lm

![alt text](https://github.com/chepurinaaa/OS-labs/blob/master/pic/1_13.png)

Пример отладки простой ошибочной программы

![alt text](https://github.com/chepurinaaa/OS-labs/blob/master/pic/1_14.png)

Применение Makefile для автоматизации (синтаксис, использование правил и переменных) make — утилита предназначенная для автоматизации преобразования файлов из одной формы в другую. Правила преобразования задаются в скрипте с именем Makefile, который должен находиться в корне рабочей директории проекта. Сам скрипт состоит из набора правил, описывающимися целями - что правило делает, реквизитами - что необходимо и командами.

`<цели>: <реквизиты> <команда> ... <команда>`

Использовать несколько целей в одном мейкфайле полезно для больших проектов. Это связано с тем, что при изменении одного файла не понадобится пересобирать весь проект, а можно будет обойтись пересборкой только измененной части.
Правило задания переменных <VAR_NAME> = Для использования значения переменной ее следует разименовать при помощи конструкции $(<VAR_NAME>).

![alt text](https://github.com/chepurinaaa/OS-labs/blob/master/pic/1_15.png)





